<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- iOS: ホーム画面アプリ化のためのメタ -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Wplace管理">
  <link rel="apple-touch-icon" href="/icons/icon-192.png">

  <!-- PWA manifest -->
  <link rel="manifest" href="/manifest.json?v=20250908">

  <title>Wplace 管理アプリ</title>

  <style>
    body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans JP",sans-serif;padding:16px;line-height:1.6}
    code,pre{background:#111827;color:#a7f3d0;padding:12px;border-radius:8px;white-space:pre-wrap}
    button{padding:10px 14px;border-radius:8px;border:1px solid #ccc;background:#fff}
    .ok{color:#16a34a}.ng{color:#dc2626}.muted{opacity:.7}
  </style>
</head>
<body>
  <h1>PWA / Push 診断</h1>

  <p>状態: <span id="status" class="ng">未確認</span></p>
  <p>ディスプレイモード: <code id="dm">-</code></p>

  <div style="display:flex;gap:8px;flex-wrap:wrap;margin:8px 0;">
    <button id="btn-re-sub">購読を再登録</button>
    <button id="btn-unsub">購読を解除</button>
    <button id="btn-check">現在の購読を確認</button>
    <button id="btn-perm">通知許可を確認/要求</button>
  </div>

  <h2>ログ</h2>
  <pre id="log"></pre>

<script>
const logEl = document.getElementById('log');
const statusEl = document.getElementById('status');
const dmEl = document.getElementById('dm');

function log(m){ logEl.textContent += (m + '\n'); }
function setOK(ok){ statusEl.textContent = ok ? 'OK' : '購読エラー'; statusEl.className = ok ? 'ok' : 'ng'; }

function displayMode(){
  const modes = ['fullscreen','standalone','minimal-ui'];
  const isStandalone = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
  if(isStandalone) return 'standalone';
  for(const m of modes){ if(window.matchMedia(`(display-mode: ${m})`).matches) return m; }
  return 'browser';
}

async function getVAPID(){
  const res = await fetch('/vapid-public-key',{cache:'no-store'});
  const t = await res.text();
  return t.trim();
}

function urlBase64ToUint8Array(base64String){
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding).replace(/-/g,'+').replace(/_/g,'/');
  const rawData = atob(base64);
  return Uint8Array.from([...rawData].map(c => c.charCodeAt(0)));
}

async function ensureSW(){
  if(!('serviceWorker' in navigator)) throw new Error('SW unsupported');
  const reg = await navigator.serviceWorker.register('/sw.js', { scope: '/' });
  await navigator.serviceWorker.ready;
  return reg;
}

async function subscribe(){
  const reg = await ensureSW();
  const key = (await getVAPID());
  const keyBytes = urlBase64ToUint8Array(key);
  log(`[VAPID] len=${key.length} decodedBytes=${keyBytes.length}`);
  if(keyBytes.length !== 65){ throw new Error('VAPID invalid length'); }

  const sub = await reg.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: keyBytes
  });
  log('[4] 購読OK endpoint=' + sub.endpoint);

  // サーバ保存
  const resp = await fetch('/push/subscribe', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(sub)
  });
  if(!resp.ok){ throw new Error('save failed'); }
  setOK(true);
  alert('購読を登録しました！');
}

async function unsubscribe(){
  const reg = await ensureSW();
  const sub = await reg.pushManager.getSubscription();
  if(sub){ await sub.unsubscribe(); }
  try{ await fetch('/push/unsubscribe', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({endpoint: sub?.endpoint||''}) }); }catch(e){}
  log('購読を解除しました。');
  setOK(false);
}

async function checkSub(){
  const reg = await ensureSW();
  const perm = 'Notification' in window ? Notification.permission : 'unknown';
  const sub = await reg.pushManager.getSubscription();
  log(`診断: PushManager=${!!reg.pushManager} permissionState= ${perm} 既存購読= ${!!sub}`);
}

async function askPerm(){
  if(!('Notification' in window)){ log('通知非対応'); return; }
  const before = Notification.permission;
  let p = before;
  if(before === 'default'){ p = await Notification.requestPermission(); }
  log(`通知許可 現在= ${p}`);
}

(async ()=>{
  const dm = displayMode();
  dmEl.textContent = dm;
  log(`[1] display-mode = ${dm}`);

  try{
    log('[2] SW 準備チェック ...');
    await ensureSW();
    log('[2] SW OK');

    await askPerm();
  }catch(e){
    log('SW/権限エラー: ' + e.message);
  }
})();
document.getElementById('btn-re-sub').onclick = async ()=>{
  try{
    const reg = await ensureSW();
    const exist = await reg.pushManager.getSubscription();
    if(exist){ await exist.unsubscribe(); log('旧購読を解除'); }
    await subscribe();
  }catch(e){
    log('購読エラー: ' + (e.message||e));
    log('ヒント: iCloudプライベートリレー / VPN / 「IPアドレスを非公開」等をOFFにして再試行してみてください。');
  }
};
document.getElementById('btn-unsub').onclick = ()=>unsubscribe();
document.getElementById('btn-check').onclick = ()=>checkSub();
document.getElementById('btn-perm').onclick = ()=>askPerm();
</script>
</body>
</html>
