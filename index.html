<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wplace 管理アプリ (Push Debug)</title>
  <link rel="manifest" href="/manifest.json" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 16px; line-height: 1.6; }
    button { padding: 10px 14px; border-radius: 8px; border: 1px solid #ccc; background: #f7f7f7; cursor: pointer; }
    #log { white-space: pre-wrap; background: #111; color: #0f0; padding: 12px; border-radius: 8px; margin-top: 12px; max-height: 50vh; overflow: auto; }
    code { background: #eee; padding: 2px 6px; border-radius: 4px; }
    .ok { color: #0a0; }
    .ng { color: #c00; }
  </style>
</head>
<body>
  <h1>Pushデバッグ</h1>

  <p>状態: <span id="state">init...</span></p>
  <p>ディスプレイモード: <code id="mode"></code></p>

  <div style="display:flex; gap:8px; flex-wrap:wrap;">
    <button id="btn-register">購読を再登録</button>
    <button id="btn-unsub">購読を解除</button>
    <button id="btn-check">現在の購読を確認</button>
    <button id="btn-perm">通知許可を確認/要求</button>
  </div>

  <h3>ログ</h3>
  <div id="log"></div>

  <script>
    const WORKER_BASE = "https://wplace-push.wplace-push-rinne.workers.dev";

    const logEl = document.getElementById('log');
    const stateEl = document.getElementById('state');
    const modeEl = document.getElementById('mode');

    function log(...args) {
      const msg = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');
      console.log('[PWA]', ...args);
      logEl.textContent += msg + '\n';
      logEl.scrollTop = logEl.scrollHeight;
    }

    function setState(s, ok=true) {
      stateEl.textContent = s;
      stateEl.className = ok ? 'ok' : 'ng';
    }

    function displayMode() {
      const m = window.matchMedia('(display-mode: standalone)').matches ? 'standalone' :
                (navigator.standalone ? 'standalone(legacy)' : 'browser');
      modeEl.textContent = m;
      return m;
    }

    async function urlBase64ToUint8Array(base64String) {
      const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
      const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
      const raw = atob(base64);
      const outputArray = new Uint8Array(raw.length);
      for (let i = 0; i < raw.length; ++i) outputArray[i] = raw.charCodeAt(i);
      return outputArray;
    }

    async function getVapidKey() {
      const res = await fetch(`${WORKER_BASE}/vapid-public-key`);
      if (!res.ok) throw new Error(`vapid-public-key ${res.status}`);
      const txt = (await res.text()).trim();
      if (!txt || /[^A-Za-z0-9\-\_]/.test(txt)) {
        // ほぼありえませんが、誤ったキー文字列検出用
        throw new Error('VAPID 公開鍵の形式が不正です');
      }
      return txt;
    }

    async function ensureSW() {
      if (!('serviceWorker' in navigator)) throw new Error('Service Worker非対応');
      // 2重登録対策：既存があればそれを使う
      let reg = await navigator.serviceWorker.getRegistration();
      if (!reg) {
        log('SW: register start');
        reg = await navigator.serviceWorker.register('/sw.js', { scope: './' });
        log('SW: register OK');
      } else {
        log('SW: already registered');
      }
      // ready 待機
      const ready = await navigator.serviceWorker.ready;
      if (!ready) throw new Error('SW ready 取得失敗');
      return ready;
    }

    async function requestPermissionIfNeeded() {
      const cur = Notification.permission;
      log('通知許可 現在=', cur);
      if (cur === 'granted') return 'granted';
      if (cur === 'denied') return 'denied';
      const res = await Notification.requestPermission();
      log('通知許可 リクエスト結果=', res);
      return res;
    }

    async function subscribe() {
      setState('subscribe…');
      try {
        displayMode();
        const perm = await requestPermissionIfNeeded();
        if (perm !== 'granted') {
          setState('通知が許可されていません', false);
          log('通知が許可されていません。iOSの「設定 > 通知」で当アプリを許可してください。');
          return;
        }

        const reg = await ensureSW();

        const vapid = await getVapidKey();
        log('VAPID=', vapid);

        // 既存購読チェック
        let sub = await reg.pushManager.getSubscription();
        if (sub) {
          log('既存購読あり → 一旦unsubscribeして再取得');
          try {
            await sub.unsubscribe();
          } catch (e) {
            log('unsubscribe失敗（続行）', String(e));
          }
        }

        sub = await reg.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: await urlBase64ToUint8Array(vapid),
        });

        const payload = JSON.stringify(sub);
        log('購読JSON=', payload.slice(0, 140) + '…');

        const resp = await fetch(`${WORKER_BASE}/push/subscribe`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: payload
        });

        const data = await resp.text();
        log('サーバ応答=', data);
        if (!resp.ok) {
          setState(`サーバ保存失敗(${resp.status})`, false);
          return;
        }
        setState('購読登録 OK');
      } catch (e) {
        setState('購読エラー', false);
        log('購読エラー:', e?.message || String(e));
        // 追加ヒント
        if (String(e).includes('NotAllowedError')) {
          log('ヒント: 通知がOS側で拒否されています。設定 > 通知 で許可してください。');
        }
        if (String(e).includes('InvalidCharacterError')) {
          log('ヒント: VAPID公開鍵のBase64URL形式が崩れている可能性。/vapid-public-key の値をそのまま使っているか確認。');
        }
      }
    }

    async function check() {
      try {
        const reg = await navigator.serviceWorker.getRegistration();
        if (!reg) { log('SW未登録'); setState('SW未登録', false); return; }
        const sub = await reg.pushManager.getSubscription();
        if (!sub) { log('購読なし'); setState('購読なし', false); return; }
        log('現在の購読 endpoint=', sub.endpoint);
        setState('購読あり');
      } catch (e) {
        setState('確認エラー', false);
        log('確認エラー:', e?.message || String(e));
      }
    }

    async function unsubscribe() {
      try {
        const reg = await navigator.serviceWorker.getRegistration();
        if (!reg) { log('SWなし'); setState('SWなし', false); return; }
        const sub = await reg.pushManager.getSubscription();
        if (!sub) { log('購読なし'); setState('購読なし', false); return; }
        const endpoint = sub.endpoint;
        const ok = await sub.unsubscribe();
        log('Browser unsubscribe=', ok);

        // サーバからも削除（存在しなくてもOK）
        const resp = await fetch(`${WORKER_BASE}/push/unsubscribe`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ endpoint })
        });
        const t = await resp.text();
        log('サーバ削除応答=', t);

        setState('購読解除 OK');
      } catch (e) {
        setState('解除エラー', false);
        log('解除エラー:', e?.message || String(e));
      }
    }

    document.getElementById('btn-register').addEventListener('click', subscribe);
    document.getElementById('btn-unsub').addEventListener('click', unsubscribe);
    document.getElementById('btn-check').addEventListener('click', check);
    document.getElementById('btn-perm').addEventListener('click', requestPermissionIfNeeded);

    // 初期ログ
    (async () => {
      displayMode();
      log('[1] display-mode =', modeEl.textContent);
      log('[2] SW 準備チェック…');
      try {
        await ensureSW();
        log('[2] SW OK');
      } catch (e) {
        log('[2] SW 登録失敗:', e?.message || String(e));
      }
      log('[3] 通知許可 =', Notification.permission);
    })();
  </script>
</body>
</html>
